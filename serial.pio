.program serial_rx
baudloop:               ; Wait for a clean 115200 baud start bit:
  wait 1 pin 0          ;   Wait for rx pin to go high
  wait 0 pin 0 [9]      ;   Wait for rx pin to go low, then wait 9 cycles
  jmp pin byteloop      ;   If rx pin is high, start receiving
  jmp baudloop          ;   Otherwise serial is still transmitting at 74880 baud
byteloop:               ; Receive data at 115200 baud:
  set x, 7              ;   Set bit counter
  bitloop:              ;   Receive 8 bits:
    in pins, 1          ;     Receive bit
    jmp x-- bitloop [6] ;     Wait for next bit
  wait 0 pin 0 [11]     ;   Wait for start bit, then wait until middle of next bit
  jmp byteloop

.program serial_tx
.side_set 1 opt
pull side 1 [7]         ; Pull data from fifo, and send a stop bit
set x, 7 side 0 [7]     ; Set bit counter, and send a start bit
bitloop:                ; Send 8 bits
  out pins, 1
  jmp x-- bitloop [6]

% c-sdk {

  // Set serial parameters here.
  // Changing the baud rate will break the receive code. Comment out the first
  // 5 lines of the serial_rx PIO program above.
  #define SERIAL_PIN_RX 1
  #define SERIAL_PIN_TX 2
  #define SERIAL_BAUDRATE 115200
  #define SERIAL_BUFSIZE 4096

  // Select which PIO and state machines to use
  #define SERIAL_PIO pio1
  #define SERIAL_PIO_RX_SM 0
  #define SERIAL_PIO_TX_SM 1
  
  uint8_t serial_rx_buf[SERIAL_BUFSIZE];
  uint serial_rx_buf_start = 0;
  uint serial_rx_buf_end = 0;
  static inline void serial_read_into_buf();

  static inline void serial_init() {
    // Calculate the clock divisor needed to get the requested baud rate
    float div = (float)clock_get_hz(clk_sys) / (8 * SERIAL_BAUDRATE);

    // Initialise the RX pin
    pio_sm_set_consecutive_pindirs(SERIAL_PIO, SERIAL_PIO_RX_SM, SERIAL_PIN_RX, 1, false);
    pio_gpio_init(SERIAL_PIO, SERIAL_PIN_RX);
    gpio_pull_up(SERIAL_PIN_RX);
    uint offset_rx = pio_add_program(SERIAL_PIO, &serial_rx_program);
    pio_sm_config c_rx = serial_rx_program_get_default_config(offset_rx);
    sm_config_set_in_pins(&c_rx, SERIAL_PIN_RX);
    sm_config_set_jmp_pin(&c_rx, SERIAL_PIN_RX);
    sm_config_set_in_shift(&c_rx, true, true, 8);
    sm_config_set_fifo_join(&c_rx, PIO_FIFO_JOIN_RX);
    sm_config_set_clkdiv(&c_rx, div);
    pio_sm_init(SERIAL_PIO, SERIAL_PIO_RX_SM, offset_rx, &c_rx);
    pio_sm_set_enabled(SERIAL_PIO, SERIAL_PIO_RX_SM, true);

    // Initialise the TX pin
    pio_sm_set_consecutive_pindirs(SERIAL_PIO, SERIAL_PIO_TX_SM, SERIAL_PIN_TX, 1, true);
    pio_gpio_init(SERIAL_PIO, SERIAL_PIN_TX);
    uint offset_tx = pio_add_program(SERIAL_PIO, &serial_tx_program);
    pio_sm_config c_tx = serial_tx_program_get_default_config(offset_tx);
    sm_config_set_out_pins(&c_tx, SERIAL_PIN_TX, 1);
    sm_config_set_sideset_pins(&c_tx, SERIAL_PIN_TX);
    sm_config_set_out_shift(&c_tx, true, false, 32);
    sm_config_set_fifo_join(&c_tx, PIO_FIFO_JOIN_TX);
    sm_config_set_clkdiv(&c_tx, div);
    pio_sm_init(SERIAL_PIO, SERIAL_PIO_TX_SM, offset_tx, &c_tx);
    pio_sm_set_enabled(SERIAL_PIO, SERIAL_PIO_TX_SM, true);

    // Set up interrupts on the RX pin
    switch (SERIAL_PIO_RX_SM) {
      case 0:
        pio_set_irq0_source_enabled(SERIAL_PIO, pis_sm0_rx_fifo_not_empty, true);
        break;
      case 1:
        pio_set_irq0_source_enabled(SERIAL_PIO, pis_sm1_rx_fifo_not_empty, true);
        break;
      case 2:
        pio_set_irq0_source_enabled(SERIAL_PIO, pis_sm2_rx_fifo_not_empty, true);
        break;
      case 3:
        pio_set_irq0_source_enabled(SERIAL_PIO, pis_sm3_rx_fifo_not_empty, true);
        break;
    }
    uint irq = pio_get_index(SERIAL_PIO) == 0 ? PIO0_IRQ_0 : PIO1_IRQ_0;
    irq_set_exclusive_handler(irq, serial_read_into_buf);
    irq_set_enabled(irq, true);
  }

  static inline void serial_putc(char c) {
    // Send one byte (blocking)
    pio_sm_put_blocking(SERIAL_PIO, SERIAL_PIO_TX_SM, (uint32_t)c);
  }

  static inline bool serial_ready() {
    // Returns true if there is data in the receive buffer
    return !(serial_rx_buf_start == serial_rx_buf_end);
  }

  static inline void serial_read_into_buf() {
    // Read data from the RX pin into the receive buffer
    io_rw_8 *rxfifo_shift = (io_rw_8*)&SERIAL_PIO->rxf[SERIAL_PIO_RX_SM] + 3;
    while (!pio_sm_is_rx_fifo_empty(SERIAL_PIO, SERIAL_PIO_RX_SM)) {
      serial_rx_buf[serial_rx_buf_end] = (uint8_t)*rxfifo_shift;
      serial_rx_buf_end = (serial_rx_buf_end + 1) % SERIAL_BUFSIZE;
    }
    pio_interrupt_clear(SERIAL_PIO, 0);
  }

  static inline char serial_getc() {
    // Read one byte from the receive buffer (blocking)
    while (!serial_ready()) tight_loop_contents();
    uint8_t byte = serial_rx_buf[serial_rx_buf_start];
    serial_rx_buf_start = (serial_rx_buf_start + 1) % SERIAL_BUFSIZE;
    return byte;
  }
%}
